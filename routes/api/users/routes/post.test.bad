import post from './post';
import models from '../../../../models';
import { getToken } from '../helpers';

jest.mock('../../../../models');

describe('Post', () => {
  it('returns a user if one is created', async () => {
    const mockRequest = {
      query: {},
      params: {},
      payload: {
        email: 'test@test.com',
        username: 'Tester',
        password: 'password',
        firstName: 'Tester',
        lastName: 'McGee'
      }
    };

    const userMock = {
      id: 1,
      email: 'test@test.com',
      username: 'test',
      password: '$2b$10$p4sMc14J4Mllzb4ywTI.6.ckLmtV8SEwBTVudHb7wcPZheoCSmA/.',
      firstName: 'Tester',
      lastName: 'Testerson',
      admin: null,
      token: getToken(1)
    };

    const h = {
      response: jest.fn().mockReturnValue({
        code: jest.fn()
      })
    };

    models.User.findOrCreate.mockImplementationOnce(() => ({
      dataValues: {
        ...userMock
      },
      ...userMock
    }));

    // HEY. This test is not working because you need to figure out a way to mock out the .spread
    // on findOrCreate. It's bad. Maybe mongo?

    // models.User.findOrCreate.spread.mockImplementationOnce(() => 'fuck');

    await post.handler(mockRequest, h);
    expect(h.response).toHaveBeenCalledWith({
      user: {
        id: userMock.id,
        email: userMock.email,
        username: userMock.username,
        firstName: userMock.firstName,
        lastName: userMock.lastName,
        admin: userMock.admin,
        token: userMock.token
      }
    });
  });

  it('returns an error if the user already exists', async () => {
    expect(true).toEqual(true);
  });

  it('returns an error if the provided data is invalid', async () => {
    expect(true).toEqual(true);
  });
});
